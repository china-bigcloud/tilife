{"./":{"url":"./","title":"精品导读","keywords":"","body":"本站介绍 本站为纯运维技术分享WIKI文档 Linux实战基础 Linux实战技巧 powered by Gitbook文件修改时间: 2022-08-05 15:19:23 undefined京ICP备12345678号 "},"Liunx实战基础/":{"url":"Liunx实战基础/","title":"Liunx实战基础","keywords":"","body":"Liunx实战攻略 powered by Gitbook文件修改时间: 2022-08-04 10:45:03 undefined京ICP备12345678号 "},"Liunx实战基础/常用命令演示.html":{"url":"Liunx实战基础/常用命令演示.html","title":"常用命令演示","keywords":"","body":"常用命令演示 %accordion% alias - 定义或显示别名%accordion% 选项： -p：显示全部已定义的别名。 例子： 显示全部已定义的别名 alias alias -p 显示已定义的别名（假设当前环境存在以下别名） alias ls alias ls grep 定义或修改别名的值 alias ls='ls --color=auto' alias ls='ls --color=never' grep='grep --color=never' 知识点 直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？ 使用编辑器打开~/.bashrc，在文件中加入别名设置，如：alias rm=’rm -i’，保存后执 行 source ~/.bashrc，这样就可以永久保存命令的别名了。 因为修改的是当前用户目录下的~/.bashrc文件，所以这样的方式只对当前用户有用。如果要对所 有用户都有效，修改/etc/bashrc文件就可以了。 %/accordion% %accordion%unalias - 删除由alias设置的别名%accordion% 选项： -a：删除全部已定义的别名。 例子： 删除全部已定义的别名 unalias -a 删除已定义的别名（假设当前环境存在以下别名） unalias vi unalias ls grep %/accordion% %accordion%bunzip2 - 创建一个bz2文件压缩包%accordion% 选项： -f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件； -k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数； -s或——small：降低程序执行时，内存的使用量； -v或——verbose：解压缩文件时，显示详细的信息； -l，--license，-V或——version：显示版本信息。 例子： 将/opt目录下的etc.zip、var.zip和backup.zip进行压缩，设置压缩率为最高，同时在压缩完 毕后不删除原始文件，显示压缩过程的详细信息。 bzip2 -9vk /opt/etc.zip /opt/var.zip /opt/backup.zip 压缩完毕后，在 /opt 下就会生成相应的etc.zip.bz2、var.zip.bz2和backup.zip.bz2文件。 %/accordion% %accordion%bzip2 - 将文件压缩成bz2格式%accordion% 选项： -c --stdout 将数据压缩或解压缩至标准输出。 -d --decompress 强制解压缩。 bzip2, bunzip2 以及 bzcat 实际上是同一个程序，进行何种操作将根据程序名 确定。 指定该选项后将不考虑这一机制，强制 bzip2 进行解压缩。 -z --compress -d 选项的补充：强制进行压缩操作，而不管执行的是哪个程序。 -t --test 检查指定文件的完整性，但并不对其解压缩。 实际上将对数据进行实验性的解压缩操作，而不输出结果。 -f --force 强制覆盖输出文件。通常 bzip2 不会覆盖已经存在的文件。该选项还强制 bzip2 打破文件的硬连接，缺省情况下 bzip2 不会这么做。 -k --keep 在压缩或解压缩时保留输入文件（不删除这些文件）。 -s --small 在压缩、解压缩及检查时减少内存用量。采用一种修正的算法进行压缩和测试，每个数据块仅需要2.5个字节。这意味着任何文件都可以在 2300k的内存中进行解压缩， 尽管速度只有通常情况下的一半。 在压缩时，-s将选定 200k 的块长度，内存用量也限制在 200k 左右， 代价是压缩率会降低。 总之，如果机器的内存较少（8兆字节或更少），可对所有操作都采用-s选项。参见下面的内存管理。 -q --quiet 压制不重要的警告信息。属于 I/O 错误及其它严重事件的信息将不会被压制。 -v --verbose 详尽模式 -- 显示每个被处理文件的压缩率。 命令行中更多的 -v 选项将增加详细的程度， 使bzip2 显示出许多主要用于诊断目的信息。 -L --license -V --version 显示软件版本，许可证条款及条件。 -1 to -9 在压缩时将块长度设为 100 k、200 k .. 900 k。 对解压缩没有影响。参见下面的内存管 理。 将所有后面的命令行变量看作文件名，即使这些变量以减号\"-\"打头。 可用这一选项处理以减号\"- \"打头的文件名， 例如：bzip2 -- -myfilename. --repetitive-fast --repetitive-best 这些选项在 0.9.5 及其以上版本中是多余的。 在较早的版本中，这两个选项对排序算法的行为提 供了一些粗糙的控制，有些情况下很有用。 0.9.5 及其以上版本采用了改进的算法而与这些选项无关。 例子： 压缩指定文件filename: bzip2 filename 或 bzip2 -z filename 这里，压缩的时候不会输出，会将原来的文件filename给删除，替换成filename.bz2.如果以前有 filename.bz2则不会替换并提示错误（如果想要替换则指定-f选项，例如 bzip2 -f filename； 如果filename是目录则也提醒错误不做任何操作；如果filename已经是压过的了有bz2后缀就提醒一 下，不再压缩，没有bz2后缀会再次压缩。 解压指定的文件filename.bz2: bzip2 -d filename.bz2 或 bunzip2 filename.bz2 这里，解压的时候没标准输出，会将原来的文件filename.bz2给替换成filename。如果以前有 filename则不会替换并提示错误（如果想要替换则指定 -f 选项，例如 bzip2 -df filename.bz2 。 压缩解压的时候将结果也输出： $bzip2 -v filename 输入之后，输出如下： filename: 0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out. %/accordion% %accordion%gunzip - 用来解压缩gz文件%accordion% 选项： -a或——ascii：使用ASCII文字模式； -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备； -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接； -h或——help：在线帮助； -l或——list：列出压缩文件的相关信息； -L或——license：显示版本与版权信息； -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理； -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上； -q或——quiet：不显示警告信息； -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； -S或或----suffix：更改压缩字尾字符串； -t或——test：测试压缩文件是否正确无误； -v或——verbose：显示指令执行过程； -V或——version：显示版本信息； 例子： 首先将/etc目录下的所有文件以及子目录进行压缩，备份压缩包etc.zip到/opt目录，然后对etc.zip文件进行gzip压缩，设置gzip的压缩级别为9。 zip –r /opt/etc.zip /etc gzip -9v /opt/etc.zip 查看上述etc.zip.gz文件的压缩信息。 gzip -l /opt/etc.zip.gz compressed uncompressed ratio uncompressed_name 11938745 12767265 6.5% /opt/etc.zip 解压上述etc.zip.gz文件到当前目录。 [root@mylinux ~]#gzip –d /opt/etc.zip.gz 或者执行 [root@mylinux ~]#gunzip /opt/etc.zip.gz %/accordion% %accordion%gzip - 用来压缩文件%accordion% 选项： -a或——ascii：使用ASCII文字模式； -d或--decompress或----uncompress：解开压缩文件； -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接； -h或——help：在线帮助； -l或——list：列出压缩文件的相关信息； -L或——license：显示版本与版权信息； -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记； -N或——name：压缩文件时，保存原来的文件名称及时间戳记； -q或——quiet：不显示警告信息； -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； -S或或----suffix：更改压缩字尾字符串； -t或——test：测试压缩文件是否正确无误； -v或——verbose：显示指令执行过程； -V或——version：显示版本信息； -：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高； --best：此参数的效果和指定“-9”参数相同； --fast：此参数的效果和指定“-1”参数相同。 -num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示 最慢压缩方法（高压缩比）。系统缺省值为6。 例子： 把test6目录下的每个文件压缩成.gz文件 gzip * 把上例中每个压缩的文件解压，并列出详细的信息 gzip -dv * 详细显示例1中每个压缩的文件的信息，并不解压 gzip -l * 压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz gzip -r log.tar 递归的压缩目录 gzip -rv test6 这样，所有test下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz.这就是 压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。 递归地解压目录 gzip -dr test6 %/accordion% %accordion%jar - 用来压缩或解压文件%accordion% 选项： -c 创建新档案 -t 列出要归档的目录 -x 从存档中提取命名（或所有）文件 -u 更新现有档案 -v 在标准输出上生成详细输出 -f 指定归档文件名 -m 包含来自指定清单文件的清单信息 -n 在创建新存档后执行Pack200规范化 -e 指定独立应用程序的应用程序入口点捆绑到可执行的jar文件中 -0 只存储；不使用ZIP压缩 -P 从文件名保留前导的“ /”（绝对路径）和“ ..”（父目录）组件 -M 不为条目创建清单文件 -i 为指定的jar文件生成索引信息 -C 更改为指定目录并包含以下文件 例子： 将当前目录下所有文件压缩成.war包 jar -cvfM0 file2.war ./ 解压缩.war包到当前目录 jar -xvf file.war 将两个类文件归档到名为classes.jar的归档文件中 jar cvf classes.jar Foo.class Bar.class 使用现有清单文件“ mymanifest”并将所有foo/目录中的文件放入\"classes.jar\" jar cvfm classes.jar mymanifest -C foo/ %/accordion% %accordion%dmesg - 显示Linux系统启动信息%accordion% dmesg命令被用于检查和控制内核的环形缓冲区。kernel会将开机信息存储在ring buffer中。您 若是开机时来不及查看信息，可利用dmesg来查看。开机信息保存在/var/log/dmesg文件里。 例子： 查看硬盘基础信息 dmesg | grep sda [ 2.442555] sd 0:0:0:0: [sda] 488281250 512-byte logical blocks: (250 GB/232 GiB) [ 2.442590] sd 0:0:0:0: [sda] Write Protect is off [ 2.442592] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00 [ 2.442607] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA [ 2.447533] sda: sda1 [ 2.448503] sd 0:0:0:0: [sda] Attached SCSI disk %/accordion% %accordion%dmidecode - 在Linux系统下获取有关硬件方面的信息%accordion% DMI的主要组成部分是Management Information Format(MIF)数据库。这个数据库包括了所有有关电脑系统和配件的信息。通过DMI，用户可以获取序列号、电脑厂商、串口信息以及其它系统配件信息。 选项： -d：(default:/dev/mem)从设备文件读取信息，输出内容与不加参数标准输出相同。 -h：显示帮助信息。 -s：只显示指定DMI字符串的信息。(string) -t：只显示指定条目的信息。(type) -u：显示未解码的原始条目内容。 --dump-bin file：将DMI数据转储到一个二进制文件中。 --from-dump FILE：从一个二进制文件读取DMI数据。 -V：显示版本信息。 例子： dmidecode -t 1 # 查看服务器信息 dmidecode | grep 'Product Name' # 查看服务器型号 dmidecode |grep 'Serial Number' # 查看主板的序列号 dmidecode -t 2 # 查看主板信息 dmidecode -s system-serial-number # 查看系统序列号 dmidecode -t memory # 查看内存信息 dmidecode -t 11 # 查看OEM信息 dmidecode -t 17 # 查看内存条数 dmidecode -t 16 # 查询内存信息 dmidecode -t 4 # 查看CPU信息 cat /proc/scsi/scsi # 查看服务器硬盘信息 查看内存的插槽数，已经使用多少插槽。每条内存多大，已使用内存多大 dmidecode|grep -P -A5 \"Memory\\s+Device\"|grep Size|grep -v Range 查看内存支持的最大内存容量 dmidecode|grep -P 'Maximum\\s+Capacity' %/accordion% %accordion%dos2unix - 将DOS格式文本文件转换成Unix格式%accordion% DOS下的文本文件是以 \\r\\n 作为断行标志的，表示成十六进制就是0D0A。而Unix下的文本文件是以\\n作为断行标志的，表示成十六进制就是0A。DOS格式的文本文件在Linux底下，用较低版本的vi打开时行尾会显示 ^M ，而且很多命令都无法很好的处理这种格式的文件，如果是个shell脚本，。而Unix格式的文本文件在Windows下用Notepad打开时会拼在一起显示。因此产生了两种格式文件相互转换的需求，对应的将UNIX格式文本文件转成成DOS格式的是unix2dos命令。 选项： -k：保持输出文件的日期不变 -q：安静模式，不提示任何警告信息。 -V：查看版本 -c：转换模式，模式有：ASCII, 7bit, ISO, Mac, 默认是：ASCII。 -o：写入到源文件 -n：写入到新文件 例子： 最简单的用法就是dos2unix直接跟上文件名： dos2unix file 如果要保持文件时间戳不变，加上-k参数。所以上面几条命令都是可以加上-k参数来保持文件 时间戳的。 dos2unix -k file dos2unix -k file1 file2 file3 dos2unix -k -o file1 file2 file3 dos2unix -k -n oldfile newfile 转换当前目录下所有文件 find -type f | xargs dos2unix %/accordion% %accordion%ln - 用来为文件创建链接%accordion% ln命令用来为文件创建链接，链接类型分为硬链接和符号链接两种，默认的链接类型是硬链接。如果 要创建符号链接必须使用”-s”选项。 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。 选项： --backup[=CONTROL] 为每个已存在的目标文件创建备份文件 -b 类似--backup，但不接受任何参数 -d, -F, --directory 创建指向目录的硬链接(只适用于超级用户) -f, --force 强行删除任何已存在的目标文件 -i, --interactive 覆盖既有文件之前先询问用户； -L, --logical 取消引用作为符号链接的目标 -n, --no-dereference 把符号链接的目的目录视为一般文件； -P, --physical 直接将硬链接到符号链接 -r, --relative 创建相对于链接位置的符号链接 -s, --symbolic 对源文件建立符号链接，而非硬链接； -S, --suffix=SUFFIX 用\"-b\"参数备份目标文件后，备份文件的字尾会被加上一个备份字符 串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它； -t, --target-directory=DIRECTORY 指定要在其中创建链接的DIRECTORY -T, --no-target-directory 将“LINK_NAME”视为常规文件 -v, --verbose 打印每个链接文件的名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出 例子： 将目录/usr/mengqc/mub1下的文件m2.c链接到目录/usr/liu下的文件a2.c cd /usr/mengqc ln /mub1/m2.c /usr/liu/a2.c 在执行ln命令之前，目录/usr/liu中不存在a2.c文件。执行ln之后，在/usr/liu目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用 ls -l 命令可以看到链接数的变化。 在目录/usr/liu下建立一个符号链接文件abc，使它指向目录/usr/mengqc/mub1 ln -s /usr/mengqc/mub1 /usr/liu/abc 执行该命令后， /usr/mengqc/mub1代表的路径将存放在名为 /usr/liu/abc的文件中。 知识点： 硬链接 建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如图所示的m2.c文件就在目录mub1和liu中都建立了目录项。 创建硬链接后，己经存在的文件的I节点号（Inode）会被多个目录文件项使用。一个文件的硬链接数 可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为l。 在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接 数为0，否则不会从文件系统中被物理地删除。 对硬链接有如下限制： 不能对目录文件做硬链接。 不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统 中。 符号链接 符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如图中的abc文件），其中包含它提供链接的另一个文件的路径名，如图中虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。 !符号连接 与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的I节点号；而硬链接并没有建立新 文件。 符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。 用 ln -s 命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。 符号链接保持了链接与源文件或目录之间的区别： 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继 续指向该文件的新数据。 在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。 符号链接的大小是其链接文件的路径名中的字节数。 当用 ln -s 命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如 lrwxrwxrwx … 14 jun 20 10:20 /etc/motd->/original_file 其中，表示“文件大小”的数字“14”恰好说明源文件名 original_file 由14个字符构成。 %/accordion% %accordion%mount - 用于挂载Linux系统外的文件%accordion% 选项： -V：显示程序版本 -h：显示辅助讯息 -v：显示较讯息，通常和 -f 用来除错。 -a：将 /etc/fstab 中定义的所有档案系统挂上。 -F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。 -f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。 -n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。 -s-r：等于 -o ro -w：等于 -o rw -L：将含有特定标签的硬盘分割挂上。 -U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意 义。 -t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。 -o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。 -o sync：在同步模式下执行。 -o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时 间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。 -o auto、-o noauto：打开/关闭自动挂上模式。 -o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async. -o dev、-o nodev-o exec、-o noexec允许执行档被执行。 -o suid、-o nosuid：允许执行档在 root 权限下执行。 -o user、-o nouser：使用者可以执行 mount/umount 的动作。 -o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。 -o ro：用唯读模式挂上。 -o rw：用可读写模式挂上。 -o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 例子： 将/dev/hda1挂在/mnt之下。 mount /dev/hda1 /mnt 将/dev/hda1用只读模式挂在/mnt之下。 mount -o ro /dev/hda1 /mnt 将/tmp/image.iso这个光盘的image档使用loop模式挂在/mnt/cdrom之下。 用这种方法可以将一般网络上可以找到的 Linux 光 碟 ISO 档在不烧录成光碟的情况下检视其内 容。 mount -o loop /tmp/image.iso /mnt/cdrom 在IP：10.1.20.21的linux上挂载mytest文件夹 mount -o username=myshare,password=myshare123 //10.4.35.77/mytest /mnt/mytest 使用mount命令。给挂载共享目录指定owner和group。uid表示用户。gid表示组 mount -o username=\"myshare\",password=\"myshare123\",uid=dev,gid=dev //10.4.35.77/mytest /mnt/mytest 给mount共享目录所在组的写权限 mount -o username=\"myshare\",password=\"myshare123\",uid=dev,gid=dev,dir_mode=0777 //10.4.35.77/mytest /mnt/mytest 挂载NFS共享目录 mount -t nfs 192.138.231.130:/usr/wjt /usr/cwjt 挂载iso文件 mount -t iso9660 -o loop /opt/CentOS-7-x86_64-DVD-1511_7.2.iso /media/CentOS7/ %/accordion% %accordion%ps - 报告当前系统的进程状态%accordion% 选项： -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。 a：显示现行终端机下的所有程序，包括其他用户的程序。 -A：显示所有程序。 -c：显示CLS和PRI栏位。 c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。 -C：指定执行指令的名称，并列出该指令的程序的状况。 -d：显示所有程序，但不包括阶段作业领导者的程序。 -e：此选项的效果和指定\"A\"选项相同。 e：列出程序时，显示每个程序所使用的环境变量。 -f：显示UID,PPIP,C与STIME栏位。 f：用ASCII字符显示树状结构，表达程序间的相互关系。 -g：此选项的效果和指定\"-G\"选项相同，当亦能使用阶段作业领导者的名称来指定。 g：显示现行终端机下的所有程序，包括群组领导者的程序。 -G：列出属于该群组的程序的状况，也可使用群组名称来指定。 h：不显示标题列。 -H：显示树状结构，表示程序间的相互关系。 -j或j：采用工作控制的格式显示程序状况。 -l或l：采用详细的格式来显示程序状况。 L：列出栏位的相关信息。 -m或m：显示所有的执行绪。 n：以数字来表示USER和WCHAN栏位。 -N：显示所有的程序，除了执行ps指令终端机下的程序之外。 -p：指定程序识别码，并列出该程序的状况。 p：此选项的效果和指定\"-p\"选项相同，只在列表格式方面稍有差异。 r：只列出现行终端机正在执行中的程序。 -s：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 s：采用程序信号的格式显示程序状况。 S：列出程序时，包括已中断的子程序资料。 -t：指定终端机编号，并列出属于该终端机的程序的状况。 t：此选项的效果和指定\"-t\"选项相同，只在列表格式方面稍有差异。 -T：显示现行终端机下的所有程序。 -u：此选项的效果和指定\"-U\"选项相同。 u：以用户为主的格式来显示程序状况。 -U：列出属于该用户的程序的状况，也可使用用户名称来指定。 U：列出属于该用户的程序的状况。 v：采用虚拟内存的格式显示程序状况。 -V或V：显示版本信息。 -w或w：采用宽阔的格式来显示程序状况。 x：显示所有程序，不以终端机来区分。 X：采用旧式的Linux i386登陆格式显示程序状况。 -y：配合选项\"-l\"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位 。 -：此选项的效果和指定\"p\"选项相同。 --cols：设置每列的最大字符数。 --columns：此选项的效果和指定\"--cols\"选项相同。 --cumulative：此选项的效果和指定\"S\"选项相同。 --deselect：此选项的效果和指定\"-N\"选项相同。 --forest：此选项的效果和指定\"f\"选项相同。 --headers：重复显示标题列。 --help：在线帮助。 --info：显示排错信息。 --lines：设置显示画面的列数。 --no-headers：此选项的效果和指定\"h\"选项相同，只在列表格式方面稍有差异。 --group：此选项的效果和指定\"-G\"选项相同。 --Group：此选项的效果和指定\"-G\"选项相同。 --pid：此选项的效果和指定\"-p\"选项相同。 --rows：此选项的效果和指定\"--lines\"选项相同。 --sid：此选项的效果和指定\"-s\"选项相同。 --tty：此选项的效果和指定\"-t\"选项相同。 --user：此选项的效果和指定\"-U\"选项相同。 --User：此选项的效果和指定\"-U\"选项相同。 --version：此选项的效果和指定\"-V\"选项相同。 --widty：此选项的效果和指定\"-cols\"选项相同。 例子： ps axo pid,comm,pcpu # 查看进程的PID、名称以及CPU 占用率 ps aux | sort -rnk 4 # 按内存资源的使用量对进程进行排序 ps aux | sort -nk 3 # 按 CPU 资源的使用量对进程进行排序 ps -A # 显示所有进程信息 ps -u root # 显示指定用户信息 ps -efL # 查看线程数 ps -e -o \"%C : %p :%z : %a\"|sort -k5 -nr # 查看进程并按内存使用大小排列 ps -ef # 显示所有进程信息，连同命令行 ps -ef | grep ssh # ps 与grep 常用组合用法，查找特定进程 ps -C nginx # 通过名字或命令搜索进程 ps aux --sort=-pcpu,+pmem # CPU或者内存进行排序,-降序，+升序 ps -f --forest -C nginx # 用树的风格显示进程的层次关系 ps -o pid,uname,comm -C nginx # 显示一个父进程的子进程 ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm # 重定义标签 ps -e -o pid,comm,etime # 显示进程运行的时间 ps -aux | grep named # 查看named进程详细信息 ps -o command -p 91730 | sed -n 2p # 通过进程id获取服务名称 相关信息列说明： F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍 UID 程序被该 UID 所拥有 PID 就是这个程序的 ID ！ PPID 则是其上级父程序的ID C CPU 使用的资源百分比 PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍 NI 这个是 Nice 值，在下一小节我们会持续介绍 ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程 序，一般就是 “-“ SZ 使用掉的内存大小 WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作 TTY 登入者的终端机位置 TIME 使用掉的 CPU 时间。 CMD 所下达的指令为何 USER：该 process 属于那个使用者账号的 PID ：该 process 的号码 %CPU：该 process 使用掉的 CPU 资源百分比 %MEM：该 process 所占用的物理内存百分比 VSZ ：该 process 使用掉的虚拟内存量 (Kbytes) RSS ：该 process 占用的固定的内存量 (Kbytes) TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1- tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：该程序目前正在运作，或者是可被运作 S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：该程序目前正在侦测或者是停止了 Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状 态 START：该 process 被触发启动的时间 TIME ：该 process 实际使用 CPU 运作的时间 COMMAND：该程序的实际指令 %/accordion% %accordion%rsync - 远程数据同步工具%accordion% rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 rsync有六种不同的工作模式： 1.拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。 如： rsync -a /data /backup 2.使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。 如： rsync -avz *.c foo:src 3.使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。 如： rsync -avz foo:src/bar /data 4.从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。 如： rsync -av root@192.168.78.192::www /databack 5.从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。 如： rsync -av /databack root@192.168.78.192::www 6.列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。 如： rsync -v rsync://192.168.78.192/www 选项： -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 ~filename。可以使用--suffix选项来指定不同的备份文件前缀。 --backup-dir 将备份文件(如~filename)存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆 盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。 --safe-links 忽略指向SRC路径目录树以外的链结。 -H, --hard-links 保留硬链结。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。 -n, --dry-run现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。 -e, --rsh=command 指定使用rsh、ssh方式进行数据同步。 --rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。 -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。 --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。 --delete 删除那些DST中SRC没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现IO错误也进行删除。 --max-delete=NUM 最多删除NUM个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组id匹配为用户名和组名。 --timeout=time ip超时时间，单位为秒。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。 -T --temp-dir=DIR 在DIR中创建临时文件。 --compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。 -P 等同于 --partial。 --progress 显示备份过程。 -z, --compress 对备份的文件在传输时进行压缩处理。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除FILE中指定模式的文件。 --include-from=FILE 不排除FILE指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。 --port=PORT 指定其他的rsync服务端口。 --blocking-io 对远程shell使用阻塞IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从FILE中得到密码。 --bwlimit=KBPS 限制I/O带宽，KBytes per second。 -h, --help 显示帮助信息。 例子： 主配置文件为“/etc/rsyncd.conf”内容如下： vi /etc/rsyncd.conf uid=root gid=root max connections=4 log file=/var/log/rsyncd.log pid file=/var/run/rsyncd.pid lock file=/var/run/rsyncd.lock secrets file=/etc/rsyncd.passwd hosts deny=172.16.78.0/22 [www] comment= backup web path=/www read only = no exclude=test auth users=work 创建密码文件，采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为“username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把 创建的密码文件权限设置为600，这在前面的模块参数做了详细介绍。 echo \"work:abc123\" > /etc/rsyncd.passwd chmod 600 /etc/rsyncd.passwd 现在就可以对数据进行备份了，如下： rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsync 使用rsync对数据进行恢复 rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::www %/accordion% %accordion%scp - 加密的方式在本地主机和远程主机之间复制文件%accordion% scp非常不占资源，不会提高多少系统负 荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 选项： -1：使用ssh协议版本1； -2：使用ssh协议版本2； -4：使用ipv4； -6：使用ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定ssh配置文件； -i：identity_file 从指定文件中读取传输时使用的密钥文件（例如亚马逊云pem），此参数直接传递给 ssh； -l：指定宽带限制； -o：指定使用的ssh选项； -P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 例子： 从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 从远处复制文件到本地目录 scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 从10.10.10.10机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz文件到本地/opt/soft/目录中。 从亚马逊云复制OpenVPN到本地目录 scp -i amazon.pem ubuntu@10.10.10.10:/usr/local/openvpn_as/etc/exe/openvpn- connect-2.1.3.110.dmg openvpn-connect-2.1.3.110.dmg 从10.10.10.10机器上下载openvpn安装文件到本地当前目录来。 从远处复制到本地 scp -r root@10.10.10.10:/opt/soft/mongodb /opt/soft/ 从10.10.10.10机器上的/opt/soft/中下载mongodb目录到本地的 /opt/soft/ 目录来。 上传本地文件到远程机器指定目录 scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest 指定端口 2222 scp -rp -P 2222 /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest 复制本地/opt/soft/目录下的文件nginx-0.5.38.tar.gz到远程机器10.10.10.10 的/opt/soft/scptest目录。 上传本地目录到远程机器指定目录 scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest 上传本地目录/opt/soft/mongodb到远程机器10.10.10.10上/opt/soft/scptest的目录中去。 %/accordion% %accordion%tcpdump - 一款sniffer工具，是Linux上的抓包工具，嗅探器%accordion% 选项： -a：尝试将网络和广播地址转换成名称； -c：收到指定的数据包数目后，就停止进行倾倒操作； -d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出； -dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出； -ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出； -e：在每列倾倒资料上显示连接层级的文件头； -f：用数字显示网际网络地址； -F：指定内含表达方式的文件； -i：使用指定的网络截面送出数据包； -l：使用标准输出列的缓冲区； -n：不把主机的网络地址转换成名字； -N：不列出域名； -O：不将数据包编码最佳化； -p：不让网络界面进入混杂模式； -q ：快速输出，仅列出少数的传输协议信息； -r：从指定的文件读取数据包数据； -s：设置每个数据包的大小； -S：用绝对而非相对数值列出TCP关联数； -t：在每列倾倒资料上不显示时间戳记； -tt： 在每列倾倒资料上显示未经格式化的时间戳记； -T：强制将表达方式所指定的数据包转译成设置的数据包类型； -v：详细显示指令执行过程； -vv：更详细显示指令执行过程； 例子： 监视指定网络接口的数据包 tcpdump -i eth1 如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络 接口。 监视指定主机的数据包 打印所有进入或离开sundown的数据包。 tcpdump host sundown 也可以指定ip,例如截获所有210.27.48.1的主机收到的和发出的所有的数据包 tcpdump host 210.27.48.1 打印helios 与 hot 或者与 ace 之间通信的数据包 tcpdump host helios and \\( hot or ace \\) 截获主机210.27.48.1和主机210.27.48.2或210.27.48.3的通信 tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) 打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包. tcpdump ip host ace and not helios 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： tcpdump ip host 210.27.48.1 and ! 210.27.48.2 截获主机hostname发送的所有数据 tcpdump -i eth0 src host hostname 监视所有送到主机hostname的数据包 tcpdump -i eth0 dst host hostname 监视指定主机和端口的数据包 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令 tcpdump tcp port 23 and host 210.27.48.1 对本机的udp 123端口进行监视123为ntp的服务端口 tcpdump udp port 123 监视指定网络的数据包 打印本地主机与Berkeley网络上的主机之间的所有通信数据包 tcpdump net ucb-ether ucb-ether此处可理解为“Berkeley网络”的网络地址，此表达式最原始的含义可表达为：打印网络地 址为ucb-ether的所有数据包 打印所有通过网关snup的ftp数据包 tcpdump 'gateway snup and (port ftp or ftp-data)' 注意：表达式被单引号括起来了，这可以防止shell对其中的括号进行错误解析 打印所有源地址或目标地址是本地主机的IP数据包 tcpdump ip and not net localnet 如果本地网络通过网关连到了另一网络，则另一网络并不能算作本地网络。 抓取80端口的HTTP报文，以文本形式展示： sudo tcpdump -i any port 80 -A %/accordion% 声明： 以上内容摘自《Linux命令大全搜索工具v1.5.1》 powered by Gitbook文件修改时间: 2022-08-05 15:05:40 undefined京ICP备12345678号 "},"Liunx实战基础/性能监控演示.html":{"url":"Liunx实战基础/性能监控演示.html","title":"性能监控演示","keywords":"","body":"性能监控演示 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战基础/网络监控演示.html":{"url":"Liunx实战基础/网络监控演示.html","title":"网络监控演示","keywords":"","body":"网络监控演示 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战基础/安全检测演示.html":{"url":"Liunx实战基础/安全检测演示.html","title":"安全检测演示","keywords":"","body":"安全检测演示 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战技巧/":{"url":"Liunx实战技巧/","title":"Liunx实战技巧","keywords":"","body":"Liunx实战攻略 powered by Gitbook文件修改时间: 2022-08-04 10:45:03 undefined京ICP备12345678号 "},"Liunx实战技巧/系统优化配置.html":{"url":"Liunx实战技巧/系统优化配置.html","title":"系统优化配置","keywords":"","body":"系统优化配置 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战技巧/Nginx配置.html":{"url":"Liunx实战技巧/Nginx配置.html","title":"Nginx配置","keywords":"","body":"Nginx配置 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战技巧/监控体系讲解.html":{"url":"Liunx实战技巧/监控体系讲解.html","title":"监控体系讲解","keywords":"","body":"监控体系讲解 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "},"Liunx实战技巧/Shell脚本语言.html":{"url":"Liunx实战技巧/Shell脚本语言.html","title":"Shell脚本语言","keywords":"","body":"Shell脚本语言 powered by Gitbook文件修改时间: 2022-08-05 15:15:27 undefined京ICP备12345678号 "}}